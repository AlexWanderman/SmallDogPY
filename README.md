TODO Загрузка файлов проекта на робота прямо с Гитхаба для возможности их обновления;
TODO Перевод инструкций на английский;
TODO Автоматизировать установку библиотек и настройку джойстика;

[Алгоритм ходьбы](walk.md)

# Подготовка рабочего места

## Прошивка карты памяти

Прежде всего нам необходимо прошить карту памяти с нужными настройками. Для этого в программе **Raspberry Pi Imager** в качестве ОС выбираем **Raspberry Pi OS Lite (64 bit)**. Включаем **доступ по SSH** и **беспроводное соединение**. Записываем логин, SSID и пароли, чтобы не забыть.

## Установка VS Code и плагинов

Устанавливаем **Visual Studio Code**. Открываем список плагинов на панели слева и устанавливаем плагины: **Python** (Microsoft), **Pylance** (Microsoft), **Remote Development** (Microsoft).

## Что мы получили

Теперь у нас есть прошитая карта памяти, готовый к работе робот (не забудьте зарядить) и ноутбук (либо пк) с установленной IDE.

# Подготовка робота

## Создание точки доступа

Создаем точку доступа с нашими SSID и паролем. Проще всего для этого использовать Android смартфон, так как нам понадобится найти IP адрес робота.

Если у вас нет под рукой андроид смартфона можно создать точку доступа на ноутбуке, либо использовать роутер. Самое главное найти IP адрес робота.

Включаем робота и ждем пока он подключится к точке доступа. В настройках точки доступа на смартфоне в списке подключенных устройств появится робот. Записываем IP адрес робота.

## Подключение по SSH

В VS Code создаем новое удаленное подключение в разделе Remote Explorer на панели слева. Указываем наши логин и IP адрес в формате **ssh login@192.168.0.1**. Вводим пароль. Первое подключение займет больше времени чем обычно.

После подключения выбираем папку **"home"**^[можно выбрать при подключении в окошке, примерно где до этого вы вводили пароль]. Нас попросят повторно ввести пароль. Чтобы удостовериться что всё работает откроем терминал и проверим содержимое папки "home" с помощью `ls -la`.

## Перенос скриптов

В папке **home** создадим папку **project** `mkdir ~/project`. С помощью VS Code загрузим туда все файлы проекта, а именно:

1. calibrate_find_motors.py - для поиска пары пина GPIO и сервомотора;
1. calibrate_parameters.py - настройки калибровки;
1. calibrate_poses.py - калибровка поз (проводится по SSH один раз);
1. main.py - скрипт для ходьбы^[Для запуска требуется доступ по SSH, буду дорабатывать];
1. test_controller.py - проверка контроллера;
1. test_servo.py - проверка pigpio (управление сервомоторами);
1. tutorial.md - эта инструкция (не обязательно).

## Обновление системы и установка плагинов

В терминале вводим `sudo apt-get update && sudo apt-get upgrade --yes` для обновления системы. После этого в VS Code повторно утсанавливаем плагины **Python** и **Pylance**. Можно перезапустить робота.

# Подготовка среды разработки

## Создание виртуальной среды Python

Для начала установим утилиту для создания виртуальных окружений `sudo apt-get install python3-venv --yes`. После этого создаем вируальное окружение `python3 -m venv env`. Активируем виртуальное окружение `source env/bin/activate`.

Далее нам нужно установить несколько библиотек для дальнейшей работы. В терминале, после активации виртуального окружения, вводим `pip install pigpio pyPS4Controller curses`.

## Установка pigpio

В терминале вводим `sudo apt-get install pigpio python3-pigpio --yes`. Добавляем демона pigpiod в автозагрузку `sudo systemctl enable pigpiod` и `sudo systemctl start pigpiod` для запуска.

Убедимся что всё работает на примере небольшой программы. Если после запуска программы не возникло никаких ошибок, то всё установленно верно.

> (env) project/test_servo.py

``` python
import pigpio
pi = pigpio.pi()
pi.stop()
```

## Подключение контроллера

Теперь мы подключим контроллер. Запустив в терминале `bluetoothctl`, предварительно запустив режим сопряжения^[Для контроллера PS4 - нажать и удерживать кнопки "Share" и копку с логотипом.], влючим обнаружение устройств `scan on`. Найдем среди устройств **Wireless Controller** и скопируем его MAC адрес^[Надо придумать как сделать чтобы он подключался автоматически при перезагрузке робота]. Подключимся к контроллеру с помощью комманды в виде **connect MAC-адрес**.

Инициализируем систему для работы с контроллером `py3ps4c init`.

После установки сопряжения перейдем ко второй тестовой программе и запустим её. Если всё сделано верно, то при нажатии на кнопки контроллера будут отображаться данные в терминале.

> (env) project/test_controller.py

``` python
from pyPS4Controller.controller import Controller
class MyController(Controller):
    def __init__(self, **kwargs):
        Controller.__init__(self, **kwargs)
controller = MyController(interface="/dev/input/js0", connecting_using_ds4drv=False)
controller.listen()
```

# Разработка системы движения

## Связь пинов и сервомоторов

Прежде всего нам нужно определить к каким пинам подключены какие сервомоторы. Для этого мы будем использовать эту (calibrate_find_motors.py) программу.

После запуска программы будет предложенно ввести номер пина и заполнение ШИМ сигнала сервомотора от 500 до 2500, где 1500 середина, а 500 и 2500 - крайние положения.

Нам необходимо пройтись по всем пинам от 0 до 31 чтобы понять какой пин отвечает за какой сервомотор. Для начала стоит брать значение ШИМ равное 1500 и смотреть какой сервомотор подвигался. Если всё в порядке, можно попробовать другие значения, близкие к 1500.

Таким образом нам нужно определить номера пинов каждого мотора. Запишем полученные значения в таблицу.

> Пример таблицы

| Лапа            | Плечо | Локоть | Кисть |
|-----------------|-------|--------|-------|
| Передняя правая | 2     | 3      | 4     |
| Передняя левая  | 14    | 15     | 17    |
| Задняя правая   | 18    | 27     | 22    |
| Задняя левая    | 23    | 24     | 25    |

> (env) project/calibrate_find_motors.py

``` python
import pigpio
pi = pigpio.pi()
while True:
    try:
        pin = int(input("Pin (0-31): "))
        pi.set_mode(pin, pigpio.OUTPUT)
        while (pwm := int(input("PWM (0, 500-2500): "))) != 0:
            if 500 <= pwm <= 2500:
                pi.set_servo_pulsewidth(pin, pwm)
            else:
                print(f"- PWM must be 0 or 500-2500, not {pwm}!")
        pi.set_servo_pulsewidth(pin, pwm)
        print("+ Done")
    except pigpio.error:
        print("- Wrong pin")
    except KeyboardInterrupt:
        print()
        break
pi.stop()
print("Exit...")
```

Теперь можно вписать полученные значения в файл с настройками (calibrate_parameters.py). Пока оставим настройки калибровки, введем только номера пинов.

1. SRV_UP_FR - плечевой м. (сервомотор) спереди (F - front) справа (R - right);
1. SRV_UP_FL - плечевой м. спереди слева;
1. SRV_UP_BR - плечевой м. сзади справа;
1. SRV_UP_BL - плечевой м. сзади слева;
1. SRV_FR - нога впереди справа, первое значение (0) - плечо, второе - кисть;
1. SRV_FL - нога впереди слева;
1. SRV_BR - нога сзади справа;
1. SRV_BL - нога сзади слева;

> (env) project/calibrate_parameters.py

``` pyhton
SRV_UP_FR = ((0,  1500, 1500),)
SRV_UP_FL = ((0,  1500, 1500),)
SRV_UP_BR = ((0,  1500, 1500),)
SRV_UP_BL = ((0,  1500, 1500),)
SRV_UP = SRV_UP_FR + SRV_UP_FL + SRV_UP_BR + SRV_UP_BL

SRV_FR = ((0,  1500, 1500), (0,  1500, 1500))
SRV_FL = ((0,  1500, 1500), (0,  1500, 1500))
SRV_BR = ((0,  1500, 1500), (0,  1500, 1500))
SRV_BL = ((0,  1500, 1500), (0,  1500, 1500))
SRV_ALL = SRV_UP + SRV_FR + SRV_FL + SRV_BR + SRV_BL
```

## Калибровка

Теперь можно перейти к калибровке. Для работы алгоритма движения нам необходимо определить два положения робота - сидя и стоя. Для этого нам понадобится следующая программа (calibrate_poses.py) и файл с настройками калибровки (calibrate_parameters.py).

После запука программы калиброки (calibrate_poses.py) мы должны выбрать позу ("0" - сидя, "1" - стоя) и стрелочками клавиатуры (влево-вправо) выбрать пин сервомотора, затем стрелочками (вверх-вниз) поменять позицию сервомотора.

Когда вы настроите одну из поз нажмите **ctrl+c** для завершения программы. Она выведет в терминал новые значения для сервомоторов, которые необходимо записать в 

## Движение

Теперь можно перейти к самому главному. Запустим основную программу (main.py). Управление осуществляется с помощью контроллера.

1. Левый стик (вперед-назад) - ходьба вперед/назад;
1. Левый стик (влево-вправо) - поворот влево/вправо, либо ходьба влево/вправо в зависимости от режима поворота;
1. Крест - встать на месте, либо продолжить ходьбу (сервомоторы нагреваются даже пока робот стоит);
1. L1 - переключание режима поворота (поворот или ходьба);
1. R1 - при удержании ускоряет робота (может резко дернуться, лучше пока не использовать);
1. Стрелка вверх - поднять робота выше относительно пола;
1. Стрелка вниз - опустить робота ниже относительно пола;

Робот будет останавливатся сам, если вернуть стик в нейтральное положение. Можно сбросить ввод стика нажав на него.
